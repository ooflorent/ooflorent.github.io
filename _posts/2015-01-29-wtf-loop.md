---
layout: post
title: Don't trust microbenchmark
pitch: What you see may not be what you getâ€¦
date: 2015-01-30
---

A few days ago, while reading [phaser3](https://github.com/photonstorm/phaser3)'s source code, I faced a weird loop optimization. The developer left a comment to explain the trick:

```js
// weird loop speed-up (http://www.paulirish.com/i/d9f0.png) gained 2fps on my rig!
for ( var i = -1, c = 0; ++i < len; c += 44 )
```

What [Paul Irish](http://www.paulirish.com) shows here is interesting. His test suggests that manually unrolling oops would improve performance. If you run his snippet in Chrome you will observe the speed boost. Let's rewrite all our loops that way! **NO! Don't blindly trust benchmarks.**

Before concluding on what happened here we need to properly benchmark things, which means, outside the `console`. This is our basic setup:

```js
function standardLoop() {
  var count = 0
  for (var i = 0; i < 1e8; i++) count += 1
  if (count !== 1e8) throw ''
}

function magicLoop() {
  var count = 0
  for (var i = -1; ++i < 1e8;) count += 1
  if (count !== 1e8) throw ''
}

function measure(test, fn) {
  var start = Date.now()
  fn()
  console.log('  ' + test + ':', String(Date.now() - start) + 'ms')
}

console.log('First run')
measure('Standard loop', standardLoop)
measure('Magic loop', magicLoop)

console.log('Second run')
measure('Standard loop', standardLoop)
measure('Magic loop', magicLoop)
```

Let's run it and take a look at the results:

    $ iojs loop.js
    First run
      Standard loop: 224ms
      Magic loop: 235ms
    Second run
      Standard loop: 158ms
      Magic loop: 209ms

Interesting! We are not able to reproduce the performance boost. But more important, the gap between the _standard_ loop and the _weird_ one has increased. This is because V8 optimized the loops. I could have stopped here saying that _standard_ loops are faster than their _weird_ alternatives but it would be a poor conclusion. No, what we really want to know is **why is there a difference?**

## Analysis

[Vyacheslav Egorov](http://mrale.ph) built an amazing tool ([IRHydra<sup>2</sup>](http://mrale.ph/irhydra/2/)) to analyze compilation artifacts produced by V8. To use it we need pass some flags to our JS engine (it works on io.js, Node.js and V8):

    $ iojs \
      --trace-hydrogen \
      --trace-phase=Z \
      --trace-deopt \
      --code-comments \
      --hydrogen-track-positions \
      --redirect-code-traces \
      --redirect-code-traces-to=code.asm \
      --print_opt_code \
      loop.js

The above command will ouput 2 files: `code.asm` and `hydrogen-xxxxx-1.cfg`. Loading them to IRHydra reveals the <abbr title="Hydrogen Intermediate Representation">HIR</abbr> instructions of our loops.

```asm
B5
i35 Phi [ i31  i56   TaggedNumber]  // var count
i36 Phi [ i32  i61   TaggedNumber]  // var i
##  for (var i = 0; i < 1e8; i++) count += 1
##                  --^----
i44 CompareNumericAndBranch LT i36 i43 goto (B6, B8) Tagged  

B6
v47 Goto B7 Tagged  

B7
##  for (var i = 0; i < 1e8; i++) count += 1
##                                -------^--
i56 Add i35 i55 ! TaggedNumber
##  for (var i = 0; i < 1e8; i++) count += 1
##                           ^--
i61 Add i36 i60 TaggedNumber  
v64 Goto B5 Tagged 
```

```asm
B5
i35 Phi [ i31  i59   TaggedNumber]
i36 Phi [ i32  i44   TaggedNumber]
##  for (var i = -1; ++i < 1e8;) count += 1
##                   --^
i44 Add i36 i43 ! TaggedNumber  
##  for (var i = -1; ++i < 1e8;) count += 1
##                   ----^----
i47 CompareNumericAndBranch LT i44 i46 goto (B6, B8) Tagged  

B6
v50 Goto B7 Tagged  
 
B7
##  for (var i = -1; ++i < 1e8;) count += 1
##                               -------^--
i59 Add i35 i58 ! TaggedNumber  
v63 Goto B5 Tagged  
```